"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[683],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,o=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=u(n),h=r,d=m["".concat(o,".").concat(h)]||m[h]||c[h]||s;return n?a.createElement(d,l(l({ref:t},p),{},{components:n})):a.createElement(d,l({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,l=new Array(s);l[0]=h;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i[m]="string"==typeof e?e:r,l[1]=i;for(var u=2;u<s;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},38725:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>i,toc:()=>u});var a=n(87462),r=(n(67294),n(3905));const s={sidebar_position:3},l="How To Serialize?",i={unversionedId:"how",id:"how",title:"How To Serialize?",description:"Every byte can represent 256 possible values. We can represent 256^2 = 65536 possible values with 2 bytes, 256^3 = 16777216 possible values with 3 bytes, and so on. There are many ways to interpret these bytes depending on context which is the key to serialization.",source:"@site/docs/how.md",sourceDirName:".",slug:"/how",permalink:"/Squash/docs/how",draft:!1,editUrl:"https://github.com/Data-Oriented-House/Squash/edit/main/docs/how.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Why Squash?",permalink:"/Squash/docs/why"},next:{title:"Packet Format And Insights",permalink:"/Squash/docs/binary"}},o={},u=[{value:"Booleans",id:"booleans",level:2},{value:"Numbers",id:"numbers",level:2},{value:"Unsigned Integers",id:"unsigned-integers",level:3},{value:"Signed Integers",id:"signed-integers",level:3},{value:"Floating Point",id:"floating-point",level:3},{value:"Variable Length Quantities",id:"variable-length-quantities",level:3},{value:"Strings",id:"strings",level:2},{value:"Using Base Conversion",id:"using-base-conversion",level:3},{value:"Tables",id:"tables",level:2},{value:"Arrays",id:"arrays",level:3},{value:"T",id:"t",level:3},{value:"Maps",id:"maps",level:3},{value:"Records",id:"records",level:3},{value:"Tuples",id:"tuples",level:2}],p={toc:u},m="wrapper";function c(e){let{components:t,...s}=e;return(0,r.kt)(m,(0,a.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-to-serialize"},"How To Serialize?"),(0,r.kt)("p",null,"Every byte can represent 256 possible values. We can represent 256^2 = 65536 possible values with 2 bytes, 256^3 = 16777216 possible values with 3 bytes, and so on. There are many ways to interpret these bytes depending on context which is the key to serialization."),(0,r.kt)("h2",{id:"booleans"},"Booleans"),(0,r.kt)("p",null,"In Luau, the ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean")," type is 1 byte large, but only 1 bit is actually necessary to store the contents of a boolean. This means we can actually serialize not just 1, but 8 booleans in a single byte. This is a common strategy called ",(0,r.kt)("em",{parentName:"p"},"bit-packing")," to implement ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Bit_field"},(0,r.kt)("em",{parentName:"a"},"bit-fields")),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Happy"),(0,r.kt)("th",{parentName:"tr",align:null},"Confused"),(0,r.kt)("th",{parentName:"tr",align:null},"Irritated"),(0,r.kt)("th",{parentName:"tr",align:null},"Concerned"),(0,r.kt)("th",{parentName:"tr",align:null},"Angry"),(0,r.kt)("th",{parentName:"tr",align:null},"Humber"),(0,r.kt)("th",{parentName:"tr",align:null},"Dazed"),(0,r.kt)("th",{parentName:"tr",align:null},"Nage"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"0")))),(0,r.kt)("p",null,"All of this information fits inside a single character! We can use this to serialize 8 booleans in a single byte. This is called a ",(0,r.kt)("em",{parentName:"p"},"byte mask"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.boolean().ser(cursor, true)\nSquash.print(cursor)\n-- Len: 8\n-- Pos: 1\n-- Buf: { 1 0 0 0 0 0 0 0 }\n--          ^\nprint(Squash.boolean().des(cursor)) -- true false false false false false false false\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor(3)\nSquash.boolean().ser(cursor, true, false, true, false, true, true, false, true)\nSquash.print(cursor)\n--- Len: 3\n--- Pos: 1\n--- Buf: { 181 0 0 }\n---            ^\nprint(Squash.boolean().des(cursor)) -- true false true false true true false true\n")),(0,r.kt)("h2",{id:"numbers"},"Numbers"),(0,r.kt)("p",null,"In Luau, the ",(0,r.kt)("inlineCode",{parentName:"p"},"number")," type is 8 bytes large, but only 52 of the bits are dedicated to storing the contents of the number. This means there is no need to serialize more than 7 bytes for any kind of integer."),(0,r.kt)("h3",{id:"unsigned-integers"},"Unsigned Integers"),(0,r.kt)("p",null,"Unsigned integers are whole numbers that can be serialized using 1 to 8 bytes."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"N = { 0, 1, 2, 3, 4, 5, . . . }"))),(0,r.kt)("p",null,"They may only be positive and can represent all possible permutations of their bits. These are the easiest to wrap our heads around and manipulate. They are often used to implement ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Fixed-point_arithmetic"},"Fixed Point")," numbers by multiplying by some scale factor and shifting by some offset, then doing the reverse when deserializing."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Bytes"),(0,r.kt)("th",{parentName:"tr",align:null},"Range"),(0,r.kt)("th",{parentName:"tr",align:null},"Min"),(0,r.kt)("th",{parentName:"tr",align:null},"Max"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"1"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ 0, 1, 2, 3, . . . , 253, 254, 255 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"0"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"255")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"2"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ 0, 1, 2, 3, . . . , 65,534, 65,535 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"0"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"65,535")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"3"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ 0, 1, 2, 3, . . . , 16,777,214, 16,777,215 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"0"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"16,777,215")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . .")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"n"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ 0, 1, 2, 3, . . . , 2^(8n) - 2, 2^(8n) - 1 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"0"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"2^(8n) - 1")))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"WARNING:")," Using 7 or 8 bytes puts uints outside the 52 bit range of representation, leading to inaccurate results."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.uint(1).ser(cursor, 243)\nSquash.print(cursor)\n-- Len: 8\n-- Pos: 1\n-- Buf: { 243 0 0 0 0 0 0 0 }\n--            ^\nprint(Squash.uint(1).des(cursor))\n-- 243\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor(1)\nSquash.uint(1).ser(cursor, -13)\nSquash.print(cursor)\n-- Len: 1\n-- Pos: 1\n-- Buf: { 243   }\n--            ^\nprint(Squash.uint(1).des(cursor))\n-- 243\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor(4, 1)\nSquash.uint(2).ser(cursor, 7365)\nSquash.print(cursor)\n-- Len: 4\n-- Pos: 3\n-- Buf: { 0 197 28 0 }\n--                 ^\nprint(Squash.uint(2).des(cursor))\n-- 7365\n")),(0,r.kt)("h3",{id:"signed-integers"},"Signed Integers"),(0,r.kt)("p",null,"Signed Integers are Integers that can be serialized with 1 through 8 bytes:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Z = { ..., -2, -1, 0, 1, 2, 3, ... }"))),(0,r.kt)("p",null,"They use ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Two%27s_complement"},"2's Compliment")," to represent negative numbers. The first bit is called the ",(0,r.kt)("em",{parentName:"p"},"sign bit")," and the rest of the bits are called the ",(0,r.kt)("em",{parentName:"p"},"magnitude bits"),". The sign bit is 0 for positive numbers and 1 for negative numbers. This implies the range of signed integers is one power of two smaller than the range of unsigned integers with the same number of bits, because the sign bit is not included in the magnitude bits."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Bytes"),(0,r.kt)("th",{parentName:"tr",align:null},"Range"),(0,r.kt)("th",{parentName:"tr",align:null},"Min"),(0,r.kt)("th",{parentName:"tr",align:null},"Max"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"1"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ -128, -127, . . . , 126, 127 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"-128"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"127")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"2"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ -32,768, -32,767, . . . , 32,766, 32,767 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"-32,768"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"32,767")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"3"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ -8,388,608, -8,388,607, . . . , 8,388,606, 8,388,607 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"-8,388,608"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"8,388,607")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . .")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"n"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ -2^(8n - 1), -2^(8n - 1) + 1, . . . , 2^(8n - 1) - 2, 2^(8n - 1) - 1 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"-2^(8n - 1)"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"2^(8n - 1) - 1")))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"WARNING:")," Using 7 or 8 bytes puts ints outside the 52 bit range of representation, leading to inaccurate results."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.int(1).ser(cursor, 127)\nSquash.print(cursor)\n-- Len: 8\n-- Pos: 1\n-- Buf: { 127 0 0 0 0 0 0 0 }\n--            ^\nprint(Squash.int(1).des(cursor))\n-- 127\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.int(1).ser(cursor, -127)\nSquash.print(cursor)\n-- Len: 8\n-- Pos: 1\n-- Buf: { 129 0 0 0 0 0 0 0 }\n--            ^\nprint(Squash.int(1).des(cursor))\n-- -127\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.int(1).ser(cursor, 128)\nSquash.print(cursor)\n-- Len: 8\n-- Pos: 1\n-- Buf: { 128 0 0 0 0 0 0 0 }\n--            ^\nprint(Squash.int(1).des(cursor))\n-- -128\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.int(1).ser(cursor, -128)\nSquash.print(cursor)\n-- Len: 8\n-- Pos: 1\n-- Buf: { 128 0 0 0 0 0 0 0 }\n--            ^\nprint(Squash.int(1).des(cursor))\n-- -128\n")),(0,r.kt)("h3",{id:"floating-point"},"Floating Point"),(0,r.kt)("p",null,"Floating Point Numbers are Rational Numbers that can be represented with either 4 or 8 bytes:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Q = { ..., -2.0, ..., -1.0, ..., 0.0, ..., 1.0, ..., 2.0, ... }"))),(0,r.kt)("p",null,"With 4 bytes (called a ",(0,r.kt)("inlineCode",{parentName:"p"},"float"),"), the possible values that can be represented are a bit more complicated. The first bit is used to represent the sign of the number, the next 8 bits are used to represent the exponent, and the last 23 bits are used to represent the mantissa."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Floating Point",src:n(39977).Z,width:"1920",height:"323"})),(0,r.kt)("p",null,"The formula for calculating the value of a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," from its sign, exponent, and mantissa can be found at ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Single-precision_floating-point_format"},"this wikipedia article"),"."),(0,r.kt)("p",null,"With 8 bytes (called a ",(0,r.kt)("inlineCode",{parentName:"p"},"double"),"). The first bit is used to represent the sign of the number, the next 11 bits are used to represent the exponent, and the last 52 bits are used to represent the mantissa."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Double Precision Floating Point",src:n(99246).Z,width:"1920",height:"388"})),(0,r.kt)("p",null,"The formula for calculating the value of a ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," from its sign, exponent, and mantissa can be found at ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Double-precision_floating-point_format"},"this wikipedia article"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.number(4).ser(cursor, 174302.923957475339573)\nSquash.print(cursor)\n-- Pos: 4 / 8\n-- Buf: { 187 55 42 72 0 0 0 0 }\n--                     ^\nprint(Squash.number(4).des(cursor))\n-- 174302.921875\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.number(8).ser(cursor, -17534840302.923957475339573)\nSquash.print(cursor)\n-- Pos: 8 / 8\n-- Buf: { 34 178 187 183 161 84 16 194   }\n--                                     ^\nprint(Squash.number(8).des(cursor))\n-- -17534840302.923958\n")),(0,r.kt)("h3",{id:"variable-length-quantities"},(0,r.kt)("a",{parentName:"h3",href:"https://en.wikipedia.org/wiki/Variable-length_quantity"},"Variable Length Quantities")),(0,r.kt)("p",null,"Sometimes we don't know how many bytes we need to represent a number, or we need to represent a number so large that 8 bytes isn't enough. This is where VLQs come in. They are a binary format to represent arbitrarily large numbers as a sequence of bytes. 7 bits encode the number, 1 bit encodes the end of the number. This means 127 serializes to 1 byte. 128 serializes to 2 bytes. It increments by powers of 128 instead of 256 like bytes because of the missing bit."),(0,r.kt)("h2",{id:"strings"},"Strings"),(0,r.kt)("p",null,"Strings are a bit trickier conceptually since they have a variable size. However to serialize with Squash is actually easier than numbers! Every character is a byte, so it is useful to think of strings are arrays of bytes. After writing each character in sequence, we need a mechanism to count how many characters we've serialized else we'll never know when to stop reading when deserializing. Right after the string, the length is serialized as a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Variable-length_quantity"},"Variable Length Quantity")," to use only necessary bytes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local cursor = Squash.cursor()\nSquash.string().ser(cursor, "Hello, World!")\nSquash.print(cursor)\n-- Pos: 14 / 18\n-- Buf: { 72 101 108 108 111 44 32 87 111 114 108 100 33 141 0 0 0 0 }\n--                                                           ^\nprint(Squash.string().des(cursor))\n-- Hello, World!\n')),(0,r.kt)("h3",{id:"using-base-conversion"},"Using Base Conversion"),(0,r.kt)("p",null,"There are many ways to compress serialized strings, a lossless approach is to treat the string itself as a number and convert the number into a higher base, or radix. This is called ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Radix"},"base conversion"),". Strings come in many different ",(0,r.kt)("em",{parentName:"p"},"flavors")," though, so we need to know how to serialize each ",(0,r.kt)("em",{parentName:"p"},"flavor"),". Each string is composed of a sequence of certain characters. The set of those certain characters is called that string's smallest ",(0,r.kt)("strong",{parentName:"p"},"Alphabet"),". For example the string ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},'"Hello, World!"'))," has the alphabet ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},'" !,HWdelorw"')),". We can assign a number to each character in the alphabet like its position in the string. With our example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"{\n    [' '] = 1, ['!'] = 2, [','] = 3, ['H'] = 4, ['W'] = 5,\n    ['d'] = 6, ['e'] = 7, ['l'] = 8, ['o'] = 9, ['r'] = 10,\n    ['w'] = 11,\n}\n")),(0,r.kt)("p",null,"This allows us to now calculate a numerical value for each string using ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Positional_notation"},"Positional Notation"),". The alphabet above has a radix of 11, so we can convert the string into a number with base 11. We can then use the base conversion formula, modified to work with strings, to convert the number with a radix 11 alphabet into a number with a radix 256 alphabet such as extended ASCII or UTF-8. To prevent our numbers from being shortened due to leading 0's, we have to use an extra character in our alphabet in the 0's place that we never use, such as the \\0 character, making our radix 12. Long story short, you can fit ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"log12(256) = 2.23"))," characters from the original string into a single character in the new string. This proccess is invertible and lossless, so we can convert the serialized string back into the original string when we are ready. To play with this concept for arbitrary alphabets, you can visit ",(0,r.kt)("a",{parentName:"p",href:"https://convert.zamicol.com/"},"Zamicol's Base Converter")," which supports these exact operations and comes with many pre-defined alphabets."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local x = 'Hello, world!'\nlocal alphabet = Squash.string.alphabet(x)\nprint(alphabet)\n--  !,Hdelorw\nlocal y = Squash.string.convert(x, alphabet, Squash.string.utf8)\nprint(y)\n-- \x03>q#\x0e\ufffd\nprint(Squash.string.convert(y, Squash.string.utf8, alphabet))\n-- 'Hello, world!'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local y = Squash.string.convert('great sword', Squash.string.lower .. ' ', Squash.string.utf8)\nprint(y)\n-- \x04\ufffdzvFV\ufffd\nprint(Squash.string.convert(y, Squash.string.utf8, Squash.string.lower .. ' '))\n-- 'great sword'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local y = Squash.string.convert('lowercase', Squash.string.lower, Squash.string.upper)\nprint(y)\n-- LOWERCASE\nprint(Squash.string.convert(y, Squash.string.upper, Squash.string.lower))\n-- lowercase\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local y = Squash.string.convert('123', Squash.string.decimal, Squash.string.binary)\nprint(y)\n-- 1111011\nprint(Squash.string.convert(y, Squash.string.binary, Squash.string.octal))\n-- 173\nprint(Squash.string.convert(y, Squash.string.binary, Squash.string.decimal))\n-- 123\nprint(Squash.string.convert(y, Squash.string.binary, Squash.string.duodecimal))\n-- A3\nprint(Squash.string.convert(y, Squash.string.binary, Squash.string.hexadecimal))\n-- 7B\nprint(Squash.string.convert(y, Squash.string.binary, Squash.string.utf8))\n-- {\n")),(0,r.kt)("h2",{id:"tables"},"Tables"),(0,r.kt)("p",null,"Luau tables are extremely versatile data structures that can and do implement every other kind of data structure one can think of. They are ",(0,r.kt)("em",{parentName:"p"},"too")," versatile to optimally serialize, which is why Squash has functions to serialize 3 kinds of common tables."),(0,r.kt)("p",null,"When defining compound types the code can become verbose and difficult to read. If this is an issue, it is encouraged to store each SerDes in a variable with a shorter name."),(0,r.kt)("h3",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"Arrays are a classic table type ",(0,r.kt)("inlineCode",{parentName:"p"},"{T}"),". Like strings, which are also arrays (of bytes), after serializing every element in sequence we append a VLQ representing the count. An array can store an array or any other table type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local arr = Squash.array\nlocal float = Squash.number(4)\nlocal myarr = arr(float)\n\nlocal cursor = Squash.cursor()\nmyarr.ser(cursor, {1, 2, 3, 4, 5.5, 6.6, -7.7, -8.9, 10.01})\nSquash.print(cursor)\n-- Pos: 37 / 40\n-- Buf: { 0 0 128 63 0 0 0 64 0 0 64 64 0 0 128 64 0 0 176 64 51 51 211 64 102 102 246 192 102 102 14 193 246 40 32 65 137 0 0 0 }\n--                                                                                                                         ^\nprint(myarr.des(cursor))\n-- 1 2 3 4 5.5 6.599999904632568 -7.699999809265137 -8.899999618530273 10.01000022888184\n")),(0,r.kt)("h3",{id:"t"},"T"),(0,r.kt)("p",null,"If using the TypeScript port of Squash this is irrelevant, but for Luau users, the type system is not powerful enough to take a table of serializers and infer the correct type. To get around this, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Squash.T")," function maps ",(0,r.kt)("inlineCode",{parentName:"p"},"SerDes<T> -> T")," and returns what you give it. It's an identity function that ",(0,r.kt)("em",{parentName:"p"},"lies")," about its type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local T = Squash.T\n\ntypeof(Squash.number(4))\n-- SerDes<number>\n\ntypeof(T(Squash.number(4)))\n-- number\n")),(0,r.kt)("h3",{id:"maps"},"Maps"),(0,r.kt)("p",null,"Maps are a classic table type ",(0,r.kt)("inlineCode",{parentName:"p"},"{ [T]: U }")," that map T's to U's. It requires using the ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," function to correctly map its types. A map can store a map or any other table type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local T = Squash.T\nlocal u = Squash.uint\nlocal vec3 = Squash.Vector3\nlocal vec2 = Squash.Vector2\nlocal mymap = Squash.map(\n    T(vec2(u(2))),\n    T(vec3(u(3)))\n)\n\nlocal cursor = Squash.cursor()\nmymap.ser(cursor, {\n    [Vector2.new(1, 2)] = Vector3.new(1, 2, 3),\n    [Vector2.new(4, 29)] = Vector3.new(4, 29, 33),\n    [Vector2.new(72, 483)] = Vector3.new(72, 483, 555),\n})\nSquash.print(cursor)\n-- Pos: 40 / 40\n-- Buf: { 43 2 0 227 1 0 72 0 0 227 1 72 0 33 0 0 29 0 0 4 0 0 29 0 4 0 3 0 0 2 0 0 1 0 0 2 0 1 0 131   }\n--                                                                                                    ^\nprint(mymap.des(cursor))\n-- {\n--    [Vector2(24346692898)] = 72, 483, 555,\n--    [Vector2(243466928B0)] = 4, 29, 33,\n--    [Vector2(243466928C8)] = 1, 2, 3\n-- }\n")),(0,r.kt)("h3",{id:"records"},"Records"),(0,r.kt)("p",null,"Records (Structs) ",(0,r.kt)("inlineCode",{parentName:"p"},"{ prop1: any, prop2: any, ... }")," map enumerated string identifiers to different values, like a named tuple. Because all keys are string literals known ahead of time, none of them have to be serialized! A record can store a record or any other table type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local T = Squash.T\nlocal u = Squash.uint\nlocal vlq = Squash.vlq()\nlocal bool = Squash.boolean()\nlocal str = Squash.string()\nlocal float = Squash.number(4)\nlocal vec2 = Squash.Vector2\nlocal arr = Squash.array\nlocal map = Squash.map\nlocal record = Squash.record\n\nlocal playerserdes = record {\n    position = T(vec2(float)),\n    health = T(u(1)),\n    name = T(str),\n    poisoned = T(bool),\n    items = T(arr(record {\n        count = T(vlq),\n        name = T(str),\n    })),\n    inns = T(map(\n        T(str),\n        T(bool)\n    )),\n}\n\nlocal cursor = Squash.cursor()\nplayerserdes.ser(cursor, {\n    position = Vector2.new(287.3855, -13486.3),\n    health = 9,\n    name = "Cedrick",\n    poisoned = true,\n    items = {\n        { name = \'Lantern\', count = 2 },\n        { name = \'Waterskin\', count = 1 },\n        { name = \'Map\', count = 4 },\n    },\n    inns = {\n        [\'The Copper Cauldron\'] = true,\n        Infirmary = true,\n        [\'His Recess\'] = true,\n    },\n})\nSquash.print(cursor)\n-- Pos: 89 / 90\n-- Buf: { 9 1 72 105 115 32 82 101 99 101 115 115 138 1 84 104\n-- 101 32 67 111 112 112 101 114 32 67 97 117 108 100 114 111\n-- 110 147 1 73 110 102 105 114 109 97 114 121 137 131 130 76\n-- 97 110 116 101 114 110 135 129 87 97 116 101 114 115 107 105\n-- 110 137 132 77 97 112 131 131 67 101 100 114 105 99 107 135\n-- 1 51 185 82 198 88 177 143 67 0 }\n--                               ^\nprint(playerserdes.des(cursor))\n-- {\n--     ["health"] = 9,\n--     ["inns"] =  \u25bc  {\n--         ["His Recess"] = true,\n--         ["Infirmary"] = true,\n--         ["The Copper Cauldron"] = true\n--     },\n--     ["items"] =  \u25bc  {\n--         [1] =  \u25bc  {\n--             ["count"] = 2,\n--             ["name"] = "Lantern"\n--         },\n--         [2] =  \u25bc  {\n--             ["count"] = 1,\n--             ["name"] = "Waterskin"\n--         },\n--         [3] =  \u25bc  {\n--             ["count"] = 4,\n--             ["name"] = "Map"\n--         }\n--     },\n--     ["name"] = "Cedrick",\n--     ["poisoned"] = true,\n--     ["position"] = 287.385498, -13486.2998\n-- }\n')),(0,r.kt)("h2",{id:"tuples"},"Tuples"),(0,r.kt)("p",null,"Tuple types ",(0,r.kt)("inlineCode",{parentName:"p"},"(T...)")," are like arrays but without the table part, and each element can be a different type. Tuples cannot be used in table types, and cannot be nested in other tuples."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local S = Squash\nlocal T = S.T\n\nlocal mytuple = S.tuple(\n    T(S.Vector3(S.number(8))),\n    T(S.CFrame(S.int(1))),\n    T(S.BrickColor()),\n    T(S.EnumItem(Enum.HumanoidStateType))\n)\n\nlocal cursor = S.cursor()\nmytuple.ser(cursor, Vector3.new(123456789, 1, 0), CFrame.new(1, 2, 3), BrickColor.new(93), Enum.HumanoidStateType.Freefall)\nS.print(cursor)\n-- Pos: 40 / 40\n-- Buf: { 0 0 0 0 0 0 0 0 0 0 0 0 0 0 240 63 0 0 0 96 52 111 157 65 1 0 0 64 64 0 0 0 64 0 0 128 63 194 0 134   }\n--                                                                                                            ^\nprint(mytuple.des(cursor))\n-- 123456792, 1, 0 1, 2, 3, 1, 0, 0, 0, 1, 0, 0, 0, 1 Medium stone grey Enum.HumanoidStateType.Freefall\n")))}c.isMDXComponent=!0},39977:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/floatingpoint-511015af5d8758076aca99bdfbae89cb.png"},99246:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/floatingpointdouble-6bb419d0e13b26edd712bd7c78838243.png"}}]);