"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6683],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),h=p(n),c=r,d=h["".concat(l,".").concat(c)]||h[c]||u[c]||i;return n?a.createElement(d,s(s({ref:t},m),{},{components:n})):a.createElement(d,s({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=c;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[h]="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},38725:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={},s="How To Serialize?",o={unversionedId:"how",id:"how",title:"How To Serialize?",description:"Every character in a string can represent 256 possible values, since there are 256 characters in extended ASCII or UTF-8. This is equivalent to 8 bits, or 1 byte. Therefore, we can represent 256^2 = 65536 possible values with 2 characters, 256^3 = 16777216 possible values with 3 characters, and so on. There are many ways to interpret these bytes depending on context. Knowing how to interpret these bytes is the key to serialization.",source:"@site/docs/how.md",sourceDirName:".",slug:"/how",permalink:"/Squash/docs/how",draft:!1,editUrl:"https://github.com/Data-Oriented-House/Squash/edit/main/docs/how.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",next:{title:"What Is SerDes?",permalink:"/Squash/docs/intro"}},l={},p=[{value:"Unsigned Integers",id:"unsigned-integers",level:2},{value:"Signed Integers",id:"signed-integers",level:2},{value:"Floating Point",id:"floating-point",level:2}],m={toc:p},h="wrapper";function u(e){let{components:t,...i}=e;return(0,r.kt)(h,(0,a.Z)({},m,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-to-serialize"},"How To Serialize?"),(0,r.kt)("p",null,"Every character in a string can represent 256 possible values, since there are 256 characters in extended ASCII or UTF-8. This is equivalent to 8 bits, or 1 byte. Therefore, we can represent 256^2 = 65536 possible values with 2 characters, 256^3 = 16777216 possible values with 3 characters, and so on. There are many ways to interpret these bytes depending on context. Knowing how to interpret these bytes is the key to serialization."),(0,r.kt)("h1",{id:"booleans"},"Booleans"),(0,r.kt)("p",null,"In Luau, the ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean")," type is 1 byte large, but only 1 bit is actually necessary to store the contents of a boolean. This means we can actually serialize not just 1, but 8 booleans in a single byte. This is a common strategy called ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Mask_(computing)"},(0,r.kt)("em",{parentName:"a"},"bit masking")),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Happy"),(0,r.kt)("th",{parentName:"tr",align:null},"Confused"),(0,r.kt)("th",{parentName:"tr",align:null},"Irritated"),(0,r.kt)("th",{parentName:"tr",align:null},"Concerned"),(0,r.kt)("th",{parentName:"tr",align:null},"Angry"),(0,r.kt)("th",{parentName:"tr",align:null},"Humber"),(0,r.kt)("th",{parentName:"tr",align:null},"Dazed"),(0,r.kt)("th",{parentName:"tr",align:null},"Nage"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"0")))),(0,r.kt)("p",null,"All of this information fits inside a single character! We can use this to serialize 8 booleans in a single byte. This is called a ",(0,r.kt)("em",{parentName:"p"},"byte mask"),"."),(0,r.kt)("h1",{id:"numbers"},"Numbers"),(0,r.kt)("p",null,"In Luau, the ",(0,r.kt)("inlineCode",{parentName:"p"},"number")," type is 8 bytes large, but only 52 of the bits are dedicated to storing the contents of the number. This means there is no need to serialize more than 8 bytes for any kind of number."),(0,r.kt)("h2",{id:"unsigned-integers"},"Unsigned Integers"),(0,r.kt)("p",null,"Unsigned Integers are Whole Numbers that can be serialized with 1 through 8 bytes:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"N = { 0, 1, 2, 3, 4, ... }"))),(0,r.kt)("p",null,"With 1 byte, the possible values that can be represented are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"N1 = { 0, 1, 2, 3, ..., 253, 254, 255 }"))),(0,r.kt)("p",null,"Where the minimum and maximum values are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"0 <= N1 <= 2^8 - 1"))),(0,r.kt)("p",null,"With 2 bytes, the possible values that can be represented are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"N2 = { 0, 1, 2, 3, ..., 65,533, 65,534, 65,535 }"))),(0,r.kt)("p",null,"Where the minimum and maximum values are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"0 <= N2 <= 2^16 - 1"))),(0,r.kt)("p",null,"With ",(0,r.kt)("em",{parentName:"p"},"n")," bytes, the possible values that can be represented are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"c = 2^8n"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Nn = { 0, 1, 2, ..., c - 2, c - 1 }"))),(0,r.kt)("p",null,"Where the minimum and maximum values are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"0 <= Nn <= c - 1"))),(0,r.kt)("h2",{id:"signed-integers"},"Signed Integers"),(0,r.kt)("p",null,"Signed Integers are Integers that can be serialized with 1 through 8 bytes:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Z = { ..., -2, -1, 0, 1, 2, 3, ... }"))),(0,r.kt)("p",null,"With 1 byte, the possible values that can be represented are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Z1 = { -128, -127, -126, ..., 125, 126, 127 }"))),(0,r.kt)("p",null,"Where the minimum and maximum values are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"-2^7 <= Z1 <= 2^7 - 1"))),(0,r.kt)("p",null,"With 2 bytes, the possible values that can be represented are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Z2 = { -32,768, -32,767, -32,766, ..., 32,765, 32,766, 32,767 }"))),(0,r.kt)("p",null,"Where the minimum and maximum values are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"-2^15 <= Z2 <= 2^15 - 1"))),(0,r.kt)("p",null,"With ",(0,r.kt)("em",{parentName:"p"},"n")," bytes, the possible values that can be represented are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"c = 2^(8n-1)"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Zn = { -c, -c + 1, -c + 2, ..., c - 3, c - 2, c - 1 }"))),(0,r.kt)("p",null,"Where the minimum and maximum values are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"-c <= Zn <= c - 1"))),(0,r.kt)("h2",{id:"floating-point"},"Floating Point"),(0,r.kt)("p",null,"Floating Point Numbers are Real Numbers that can be serialized with either 4 or 8 bytes:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"R = { ..., -2.0, ..., -1.0, ..., 0.0, ..., 1.0, ..., 2.0, ... }"))),(0,r.kt)("p",null,"With 4 bytes (called a ",(0,r.kt)("inlineCode",{parentName:"p"},"float"),"), the possible values that can be represented are a bit more complicated. The first bit is used to represent the sign of the number, the next 8 bits are used to represent the exponent, and the last 23 bits are used to represent the mantissa."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Floating Point",src:n(26863).Z,width:"1920",height:"323"})),(0,r.kt)("p",null,"The formula for calculating the value of a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," from its sign, exponent, and mantissa can be found at ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Single-precision_floating-point_format"},"this wikipedia article"),"."),(0,r.kt)("p",null,"With 8 bytes (called a ",(0,r.kt)("inlineCode",{parentName:"p"},"double"),"). The first bit is used to represent the sign of the number, the next 11 bits are used to represent the exponent, and the last 52 bits are used to represent the mantissa."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Double Precision Floating Point",src:n(65044).Z,width:"1920",height:"388"})),(0,r.kt)("p",null,"The formula for calculating the value of a ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," from its sign, exponent, and mantissa can be found at ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Double-precision_floating-point_format"},"this wikipedia article"),"."),(0,r.kt)("h1",{id:"strings"},"Strings"),(0,r.kt)("p",null,"Strings are a bit more complicated than numbers. There are many ways to compress serialized strings, a lossless approach is to treat the string itself as a number and convert the number into a higher base, or radix. This is called ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Radix"},"base conversion"),". Strings come in many different ",(0,r.kt)("em",{parentName:"p"},"flavors")," though, so we need to know how to serialize each ",(0,r.kt)("em",{parentName:"p"},"flavor"),". Each string is composed of a sequence of certain characters. The set of those certain characters is called that string's smallest ",(0,r.kt)("strong",{parentName:"p"},"Alphabet"),". For example the string ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},'"Hello, World!"'))," has the alphabet ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},'" !,HWdelorw"')),". We can assign a number to each character in the alphabet like its position in the string. With our example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"{\n    [' '] = 1, ['!'] = 2, [','] = 3, ['H'] = 4, ['W'] = 5,\n    ['d'] = 6, ['e'] = 7, ['l'] = 8, ['o'] = 9, ['r'] = 10,\n    ['w'] = 11,\n}\n")),(0,r.kt)("p",null,"This allows us to now calculate a numerical value for each string using ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Positional_notation"},"Positional Notation"),". The alphabet above has a radix of 11, so we can convert the string into a number with base 11. We can then use the base conversion formula, modified to work with strings, to convert the number with a radix 11 alphabet into a number with a radix 255 alphabet such as extended ASCII or UTF-8 minus the \\0 character. Long story short, you can fit ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"log11(255) = 2.31"))," characters from the original string into a single character in the new string. This proccess is invertible and lossless, so we can convert the serialized string back into the original string when we are ready. To play with this concept for arbitrary alphabets, you can visit ",(0,r.kt)("a",{parentName:"p",href:"https://convert.zamicol.com/"},"zamicol's base converter")," which supports these exact operations and comes with many pre-defined alphabets."))}u.isMDXComponent=!0},26863:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/floatingpoint-511015af5d8758076aca99bdfbae89cb.png"},65044:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/floatingpointdouble-6bb419d0e13b26edd712bd7c78838243.png"}}]);