"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[629],{3905:(e,n,r)=>{r.d(n,{Zo:()=>c,kt:()=>m});var t=r(67294);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function i(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},o=Object.keys(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var u=t.createContext({}),s=function(e){var n=t.useContext(u),r=n;return e&&(r="function"==typeof e?e(n):i(i({},n),e)),r},c=function(e){var n=s(e.components);return t.createElement(u.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},f=t.forwardRef((function(e,n){var r=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(r),f=a,m=d["".concat(u,".").concat(f)]||d[f]||p[f]||o;return r?t.createElement(m,i(i({ref:n},c),{},{components:r})):t.createElement(m,i({ref:n},c))}));function m(e,n){var r=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=f;var l={};for(var u in n)hasOwnProperty.call(n,u)&&(l[u]=n[u]);l.originalType=e,l[d]="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=r[s];return t.createElement.apply(null,i)}return t.createElement.apply(null,r)}f.displayName="MDXCreateElement"},56989:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>u,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var t=r(87462),a=(r(67294),r(3905));const o={sidebar_position:3},i="Advanced Techniques",l={unversionedId:"custom",id:"custom",title:"Advanced Techniques",description:"Custom Serializers",source:"@site/docs/custom.md",sourceDirName:".",slug:"/custom",permalink:"/Squash/docs/custom",draft:!1,editUrl:"https://github.com/Data-Oriented-House/Squash/edit/main/docs/custom.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"How To Serialize?",permalink:"/Squash/docs/how"},next:{title:"Packet Format And Insights",permalink:"/Squash/docs/RemoteEvents/binary"}},u={},s=[{value:"Custom Serializers",id:"custom-serializers",level:2}],c={toc:s},d="wrapper";function p(e){let{components:n,...r}=e;return(0,a.kt)(d,(0,t.Z)({},c,r,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"advanced-techniques"},"Advanced Techniques"),(0,a.kt)("h2",{id:"custom-serializers"},"Custom Serializers"),(0,a.kt)("p",null,"For the performance-concerned, Squash exposes the ",(0,a.kt)("inlineCode",{parentName:"p"},"Squash.tryrealloc(cursor: Cursor, bytes: number)")," method to make implementing custom serializers a breeze. These custom serializers can be used in conjunction with other serializers like the ",(0,a.kt)("inlineCode",{parentName:"p"},"table"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"record"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"map"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"array"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"tuple")," serializers. For example, if you have thousands of enemies represented by simple data, you may wish to serialize them all in one go without the overhead of the array."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local Squash = require(...)\n\nlocal T = Squash.T\nlocal rec = Squash.record\nlocal arr = Squash.array\nlocal i3 = Squash.int(3)\nlocal u2 = Squash.uint(2)\n\nlocal Serializers = {}\n")),(0,a.kt)("p",null,"The below example implementation wastes a few bytes at the end of each array to redundantly record a length that can only be stored once. The type could be changed to ",(0,a.kt)("inlineCode",{parentName:"p"},"{ { x: number, z: number, id: number } }")," but that comes with a performance overhead for so many table creations when deserializing."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"Serializers.enemies = rec {\n    x = T(arr(i3, u2)),\n    z = T(arr(i3, u2)),\n    id = T(arr(u2, u2))\n}\n\ndo\n    local c = Squash.cursor()\n    Serializers.enemies.ser(c, {\n        x = {-1000, 2, 3, 4},\n        z = {4, 5, 6, 7},\n        id = {10, 11, 12, 13},\n    })\n    Squash.print(c)\n    local b = Squash.tobuffer(c)\n\n    local c = Squash.frombuffer(b)\n    local data = Serializers.enemies.des(c)\n    for i = 1, #data.x do\n        print(`x: {data.x[i]}, z: {data.z[i]}, id: {data.id[i]}`)\n    end\n    --[[\n        Look, it uses 38 bytes, 4 more extra!\n\n        Pos: 38 / 40\n        Buf: { 10 0 11 0 12 0 13 0 4 0 24 252 255 2 0 0 3 0 0 4 0 0 4 0 4 0 0 5 0 0 6 0 0 7 0 0 4 0 0 0 }\n                                                                                                    ^\n        x: -1000, z: 4, id: 10\n        x: 2, z: 5, id: 11\n        x: 3, z: 6, id: 12\n        x: 4, z: 7, id: 13\n    ]]\nend\n")),(0,a.kt)("p",null,"The below implementation has less overhead and defines a custom format to only store the length once. It can serialize into the ",(0,a.kt)("inlineCode",{parentName:"p"},"{ { x: number, z: number, id: number } }")," format, but then deserialize straight into the ",(0,a.kt)("inlineCode",{parentName:"p"},"{ x: { number }, z: { number }, id: { number } }")," format."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"Serializers.enemiesManually = {\n    ser = function(cursor, data)\n        local n = #data.x\n\n        Squash.tryrealloc(cursor, 8 * n)\n        local buf = cursor.Buf\n\n        local p = cursor.Pos\n        for i = 1, n do\n            local x, z, id = data.x[i], data.z[i], data.id[i]\n\n            x = math.abs(x) * 2 + if x < 0 then 1 else 0\n            buffer.writeu8(buf, p, x)\n            p += 1\n            buffer.writeu16(buf, p, x // 256)\n            p += 2\n\n            z = math.abs(z) * 2 + if z < 0 then 1 else 0\n            buffer.writeu8(buf, p, z)\n            p += 1\n            buffer.writeu16(buf, p, z // 256)\n            p += 2\n\n            buffer.writeu16(buf, p, id)\n            p += 2\n        end\n\n        buffer.writeu16(buf, p, n)\n        p += 2\n\n        cursor.Pos = p\n    end,\n\n    des = function(cursor)\n        local buf = cursor.Buf\n        local p = cursor.Pos\n\n        p -= 2\n        local n = buffer.readu16(buf, p)\n\n        local data = {\n            x = table.create(n),\n            z = table.create(n),\n            id = table.create(n),\n        }\n        for i = n, 1, -1 do\n            p -= 2\n            local id = buffer.readu16(buf, p)\n\n            p -= 2\n            local z2 = buffer.readu16(buf, p) * 256\n            p -= 1\n            local z1 = buffer.readu8(buf, p)\n            local z = (z2 + z1) // 2 * if z1 % 2 == 0 then 1 else -1\n\n            p -= 2\n            local x2 = buffer.readu16(buf, p) * 256\n            p -= 1\n            local x1 = buffer.readu8(buf, p)\n            local x = (x2 + x1) // 2 * if x1 % 2 == 0 then 1 else -1\n\n            data.x[i], data.z[i], data.id[i] = x, z, id\n        end\n\n        return data\n    end,\n} :: SerDes<{ x: { number }, z: { number }, id: { number } }>\n\ndo\n    local c = Squash.cursor()\n    Serializers.enemiesManually.ser(c, {\n        x = {-1000, 2, 3, 4},\n        z = {4, 5, 6, 7},\n        id = {10, 11, 12, 13},\n    })\n    Squash.print(c)\n    local b = Squash.tobuffer(c)\n\n    local c = Squash.frombuffer(b)\n    local data = Serializers.enemiesManually.des(c)\n    for i = 1, #data.x do\n        print(`x: {data.x[i]}, z: {data.z[i]}, id: {data.id[i]}`)\n    end\n    --[[\n        Only 34 bytes, perfection!\n\n        Pos: 34 / 40\n        Buf: { 209 7 0 8 0 0 10 0 4 0 0 10 0 0 11 0 6 0 0 12 0 0 12 0 8 0 0 14 0 0 13 0 4 0 0 0 0 0 0 0 }\n                                                                                            ^\n        x: -1000, z: 4, id: 10\n        x: 2, z: 5, id: 11\n        x: 3, z: 6, id: 12\n        x: 4, z: 7, id: 13\n    ]]\nend\n")))}p.isMDXComponent=!0}}]);