"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[683],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),i=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=i(e.components);return a.createElement(u.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=i(n),m=r,d=c["".concat(u,".").concat(m)]||c[m]||h[m]||s;return n?a.createElement(d,o(o({ref:t},p),{},{components:n})):a.createElement(d,o({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=m;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[c]="string"==typeof e?e:r,o[1]=l;for(var i=2;i<s;i++)o[i]=n[i];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},38725:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>i});var a=n(87462),r=(n(67294),n(3905));const s={sidebar_position:2},o="How To Serialize?",l={unversionedId:"how",id:"how",title:"How To Serialize?",description:"Every byte can represent 256 possible values. We can represent 256^2 = 65536 possible values with 2 bytes, 256^3 = 16777216 possible values with 3 bytes, and so on. There are many ways to interpret these bytes depending on context which is the key to serialization. All serialization does is turn information into data, in this case datatype instances to buffers. If used smartly, less data can be used to represent the same information which is what Squash exploits as much as possible.",source:"@site/docs/how.md",sourceDirName:".",slug:"/how",permalink:"/Squash/docs/how",draft:!1,editUrl:"https://github.com/Data-Oriented-House/Squash/edit/main/docs/how.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"defaultSidebar",previous:{title:"What is Squash?",permalink:"/Squash/docs/intro"},next:{title:"Packet Format And Insights",permalink:"/Squash/docs/RemoteEvents/binary"}},u={},i=[{value:"Cursors",id:"cursors",level:2},{value:"Booleans",id:"booleans",level:2},{value:"Numbers",id:"numbers",level:2},{value:"Unsigned Integers",id:"unsigned-integers",level:3},{value:"Signed Integers",id:"signed-integers",level:3},{value:"Floating Point",id:"floating-point",level:3},{value:"Variable Length Quantities",id:"variable-length-quantities",level:3},{value:"Strings",id:"strings",level:2},{value:"Using Base Conversion",id:"using-base-conversion",level:3},{value:"Literals",id:"literals",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Maps",id:"maps",level:2},{value:"T",id:"t",level:2},{value:"Records",id:"records",level:2},{value:"Tuples",id:"tuples",level:2},{value:"Tables",id:"tables",level:2}],p={toc:i},c="wrapper";function h(e){let{components:t,...s}=e;return(0,r.kt)(c,(0,a.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-to-serialize"},"How To Serialize?"),(0,r.kt)("p",null,"Every byte can represent 256 possible values. We can represent 256^2 = 65536 possible values with 2 bytes, 256^3 = 16777216 possible values with 3 bytes, and so on. There are many ways to interpret these bytes depending on context which is the key to serialization. All serialization does is turn information into data, in this case datatype instances to buffers. If used smartly, less data can be used to represent the same information which is what Squash exploits as much as possible."),(0,r.kt)("h2",{id:"cursors"},"Cursors"),(0,r.kt)("p",null,"Buffers themselves are ",(0,r.kt)("strong",{parentName:"p"},"statically sized"),", which means that when a buffer is created it cannot be resized to fit more data. Squash uses something called a ",(0,r.kt)("strong",{parentName:"p"},"Cursor")," which wraps around buffers to treat them like ",(0,r.kt)("strong",{parentName:"p"},"dynamically sized stacks"),". This means users push and pop data off of the stack, and if it grows too big the buffer gets reallocated behind the scenes. Every serializer expects a cursor to push and pop from when serializing and deserializing. For more information, the internally used cursors have been extracted into a dedicated library called ",(0,r.kt)("a",{parentName:"p",href:"https://data-oriented-house.github.io/Cursor/"},"Cursor"),"."),(0,r.kt)("p",null,"A fun consequence of using a stack is that multiple independent serializations are allowed on the same cursor in succession. This makes fine-tuned serdes a breeze, since a user can serialize a number, then a string, then an array of vectors, and it just works!"),(0,r.kt)("h2",{id:"booleans"},"Booleans"),(0,r.kt)("p",null,"In Luau, the ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean")," type is 1 byte large, but only 1 bit is actually necessary to store the contents of a boolean. This means we can actually serialize not just 1, but 8 booleans in a single byte. This is a common strategy called ",(0,r.kt)("em",{parentName:"p"},"bit-packing")," to implement ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Bit_field"},(0,r.kt)("em",{parentName:"a"},"bit-fields")),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Happy"),(0,r.kt)("th",{parentName:"tr",align:null},"Confused"),(0,r.kt)("th",{parentName:"tr",align:null},"Irritated"),(0,r.kt)("th",{parentName:"tr",align:null},"Concerned"),(0,r.kt)("th",{parentName:"tr",align:null},"Angry"),(0,r.kt)("th",{parentName:"tr",align:null},"Humber"),(0,r.kt)("th",{parentName:"tr",align:null},"Dazed"),(0,r.kt)("th",{parentName:"tr",align:null},"Nage"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"0")))),(0,r.kt)("p",null,"All of this information fits inside a single byte! We can use this to serialize 8 booleans in a single byte."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.boolean().ser(cursor, true)\nSquash.print(cursor)\n-- Pos: 1 / 8\n-- Buf: { 1 0 0 0 0 0 0 0 }\n--          ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.boolean().des(cursor))\n-- true false false false false false false false\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor(3)\nSquash.boolean().ser(cursor, true, false, true, false, true, true, false, true)\nSquash.print(cursor)\n--- Pos: 1 / 3\n--- Buf: { 181 0 0 }\n---            ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.boolean().des(cursor))\n-- true false true false true true false true\n")),(0,r.kt)("h2",{id:"numbers"},"Numbers"),(0,r.kt)("p",null,"In Luau, the ",(0,r.kt)("inlineCode",{parentName:"p"},"number")," type is 8 bytes large, but only 52 of the bits are dedicated to storing the contents of the number. This means there is no need to serialize more than 7 bytes for any kind of integer."),(0,r.kt)("h3",{id:"unsigned-integers"},"Unsigned Integers"),(0,r.kt)("p",null,"Unsigned integers are whole numbers that can be serialized using 1 to 8 bytes."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"N = { 0, 1, 2, 3, 4, 5, . . . }"))),(0,r.kt)("p",null,"They may only be positive and can represent all possible permutations of their bits. These are the easiest to wrap our heads around and manipulate. They are often used to implement ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Fixed-point_arithmetic"},"Fixed Point")," numbers by multiplying by some scale factor and shifting by some offset, then doing the reverse when deserializing."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Bytes"),(0,r.kt)("th",{parentName:"tr",align:null},"Range"),(0,r.kt)("th",{parentName:"tr",align:null},"Min"),(0,r.kt)("th",{parentName:"tr",align:null},"Max"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"1"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ 0, 1, 2, 3, . . . , 253, 254, 255 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"0"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"255")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"2"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ 0, 1, 2, 3, . . . , 65,534, 65,535 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"0"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"65,535")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"3"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ 0, 1, 2, 3, . . . , 16,777,214, 16,777,215 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"0"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"16,777,215")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . .")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"n"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ 0, 1, 2, 3, . . . , 2^(8n) - 2, 2^(8n) - 1 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"0"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"2^(8n) - 1")))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"WARNING:")," Using 7 or 8 bytes puts uints outside the 52 bit range of representation, leading to inaccurate results."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.uint(1).ser(cursor, 243)\nSquash.print(cursor)\n-- Pos: 1 / 8\n-- Buf: { 243 0 0 0 0 0 0 0 }\n--            ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.uint(1).des(cursor))\n-- 243\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor(1)\nSquash.uint(1).ser(cursor, -13)\nSquash.print(cursor)\n-- Pos: 1 / 1\n-- Buf: { 243   }\n--            ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.uint(1).des(cursor))\n-- 243\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor(4, 1)\nSquash.uint(2).ser(cursor, 7365)\nSquash.print(cursor)\n-- Pos: 3 / 4\n-- Buf: { 0 197 28 0 }\n--                 ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.uint(2).des(cursor))\n-- 7365\n")),(0,r.kt)("h3",{id:"signed-integers"},"Signed Integers"),(0,r.kt)("p",null,"Signed Integers are Integers that can be serialized with 1 through 8 bytes:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Z = { ..., -2, -1, 0, 1, 2, 3, ... }"))),(0,r.kt)("p",null,"They use ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Two%27s_complement"},"2's Compliment")," to represent negative numbers. The first bit is called the ",(0,r.kt)("em",{parentName:"p"},"sign bit")," and the rest of the bits are called the ",(0,r.kt)("em",{parentName:"p"},"magnitude bits"),". The sign bit is 0 for positive numbers and 1 for negative numbers. This implies the range of signed integers is one power of two smaller than the range of unsigned integers with the same number of bits, because the sign bit is not included in the magnitude bits."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Bytes"),(0,r.kt)("th",{parentName:"tr",align:null},"Range"),(0,r.kt)("th",{parentName:"tr",align:null},"Min"),(0,r.kt)("th",{parentName:"tr",align:null},"Max"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"1"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ -128, -127, . . . , 126, 127 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"-128"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"127")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"2"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ -32,768, -32,767, . . . , 32,766, 32,767 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"-32,768"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"32,767")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"3"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ -8,388,608, -8,388,607, . . . , 8,388,606, 8,388,607 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"-8,388,608"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"8,388,607")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . ."),(0,r.kt)("td",{parentName:"tr",align:null},". . .")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"n"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"{ -2^(8n - 1), -2^(8n - 1) + 1, . . . , 2^(8n - 1) - 2, 2^(8n - 1) - 1 }")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"-2^(8n - 1)"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("em",{parentName:"strong"},"2^(8n - 1) - 1")))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"WARNING:")," Using 7 or 8 bytes puts ints outside the 52 bit range of representation, leading to inaccurate results."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.int(1).ser(cursor, 127)\nSquash.print(cursor)\n-- Pos: 1 / 8\n-- Buf: { 127 0 0 0 0 0 0 0 }\n--            ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.int(1).des(cursor))\n-- 127\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.int(1).ser(cursor, -127)\nSquash.print(cursor)\n-- Pos: 1 / 8\n-- Buf: { 129 0 0 0 0 0 0 0 }\n--            ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.int(1).des(cursor))\n-- -127\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.int(1).ser(cursor, 128)\nSquash.print(cursor)\n-- Pos: 1 / 8\n-- Buf: { 128 0 0 0 0 0 0 0 }\n--            ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.int(1).des(cursor))\n-- -128\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.int(1).ser(cursor, -128)\nSquash.print(cursor)\n-- Pos: 1 / 8\n-- Buf: { 128 0 0 0 0 0 0 0 }\n--            ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.int(1).des(cursor))\n-- -128\n")),(0,r.kt)("h3",{id:"floating-point"},"Floating Point"),(0,r.kt)("p",null,"Floating Point Numbers are Rational Numbers that can be represented with either 4 or 8 bytes:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Q = { ..., -2.0, ..., -1.0, ..., 0.0, ..., 1.0, ..., 2.0, ... }"))),(0,r.kt)("p",null,"With 4 bytes (called a ",(0,r.kt)("inlineCode",{parentName:"p"},"float"),"), the possible values that can be represented are a bit more complicated. The first bit is used to represent the sign of the number, the next 8 bits are used to represent the exponent, and the last 23 bits are used to represent the mantissa."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Floating Point",src:n(26863).Z,width:"1920",height:"323"})),(0,r.kt)("p",null,"The formula for calculating the value of a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," from its sign, exponent, and mantissa can be found at ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Single-precision_floating-point_format"},"this wikipedia article"),"."),(0,r.kt)("p",null,"With 8 bytes (called a ",(0,r.kt)("inlineCode",{parentName:"p"},"double"),"). The first bit is used to represent the sign of the number, the next 11 bits are used to represent the exponent, and the last 52 bits are used to represent the mantissa."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Double Precision Floating Point",src:n(65044).Z,width:"1920",height:"388"})),(0,r.kt)("p",null,"The formula for calculating the value of a ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," from its sign, exponent, and mantissa can be found at ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Double-precision_floating-point_format"},"this wikipedia article"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.number(4).ser(cursor, 174302.923957475339573)\nSquash.print(cursor)\n-- Pos: 4 / 8\n-- Buf: { 187 55 42 72 0 0 0 0 }\n--                     ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.number(4).des(cursor))\n-- 174302.921875\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.number(8).ser(cursor, -17534840302.923957475339573)\nSquash.print(cursor)\n-- Pos: 8 / 8\n-- Buf: { 34 178 187 183 161 84 16 194   }\n--                                     ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.number(8).des(cursor))\n-- -17534840302.923958\n")),(0,r.kt)("h3",{id:"variable-length-quantities"},(0,r.kt)("a",{parentName:"h3",href:"https://en.wikipedia.org/wiki/Variable-length_quantity"},"Variable Length Quantities")),(0,r.kt)("p",null,"Sometimes we don't know how many bytes we need to represent a number, or we need to represent a number so large that 8 bytes isn't enough. This is where VLQs come in. They are a binary format to represent arbitrarily large numbers as a sequence of bytes. 7 bits encode the number, 1 bit encodes the end of the number. This means 127 serializes to 1 byte. 128 serializes to 2 bytes. It increments by powers of 128 instead of 256 like bytes do because of the missing bit."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.vlq().ser(cursor, 10)\nSquash.print(cursor)\n-- Pos: 1 / 8\n-- Buf: { 138 0 0 0 0 0 0 0 }\n--            ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.vlq().des(cursor))\n-- 10\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.vlq().ser(cursor, 130)\nSquash.print(cursor)\n-- Pos: 2 / 8\n-- Buf: { 129 2 0 0 0 0 0 0 }\n--              ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.vlq().des(cursor))\n-- 130\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local cursor = Squash.cursor()\nSquash.vlq().ser(cursor, 547359474)\nSquash.print(cursor)\n-- Pos: 5 / 8\n-- Buf: { 130 5 0 21 114 0 0 0 }\n--                       ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.vlq().des(cursor))\n-- 547359474\n")),(0,r.kt)("h2",{id:"strings"},"Strings"),(0,r.kt)("p",null,"Strings are a bit trickier conceptually since they have a variable size. However to serialize with Squash is actually easier than numbers! Every character is a byte, so it is useful to think of strings are arrays of bytes. After writing each character in sequence, we need a mechanism to count how many characters we've serialized else we'll never know when to stop reading when deserializing. Right after the string, the length is serialized as a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Variable-length_quantity"},"Variable Length Quantity")," to use only necessary bytes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local cursor = Squash.cursor()\nSquash.string().ser(cursor, "Hello, World!")\nSquash.print(cursor)\n-- Pos: 14 / 18\n-- Buf: { 72 101 108 108 111 44 32 87 111 114 108 100 33 141 0 0 0 0 }\n--                                                           ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.string().des(cursor))\n-- Hello, World!\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local cursor = Squash.cursor()\nSquash.string(13).ser(cursor, "Hello, World!")\nSquash.print(cursor)\n-- Pos: 13 / 18\n-- Buf: { 72 101 108 108 111 44 32 87 111 114 108 100 33 0 0 0 0 0 }\n--                                                       ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(Squash.string(13).des(cursor))\n-- Hello, World!\n')),(0,r.kt)("h3",{id:"using-base-conversion"},"Using Base Conversion"),(0,r.kt)("p",null,"There are many ways to compress serialized strings, a lossless approach is to treat the string itself as a number and convert the number into a higher base, or radix. This is called ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Radix"},"base conversion"),". Strings come in many different ",(0,r.kt)("em",{parentName:"p"},"flavors")," though, so we need to know how to serialize each ",(0,r.kt)("em",{parentName:"p"},"flavor"),". Each string is composed of a sequence of certain characters. The set of those certain characters is called that string's smallest ",(0,r.kt)("strong",{parentName:"p"},"Alphabet"),". For example the string ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},'"Hello, World!"'))," has the alphabet ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},'" !,HWdelorw"')),". We can assign a number to each character in the alphabet like its position in the string. With our example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"{\n    [' '] = 1, ['!'] = 2, [','] = 3, ['H'] = 4, ['W'] = 5,\n    ['d'] = 6, ['e'] = 7, ['l'] = 8, ['o'] = 9, ['r'] = 10,\n    ['w'] = 11,\n}\n")),(0,r.kt)("p",null,"This allows us to now calculate a numerical value for each string using ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Positional_notation"},"Positional Notation"),". The alphabet above has a radix of 11, so we can convert the string into a number with base 11. We can then use the base conversion formula, modified to work with strings, to convert the number with a radix 11 alphabet into a number with a radix 256 alphabet such as extended ASCII or UTF-8. To prevent our numbers from being shortened due to leading 0's, we have to use an extra character in our alphabet in the 0's place that we never use, such as the \\0 character, making our radix 12. Long story short, you can fit ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"log12(256) = 2.23"))," characters from the original string into a single character in the new string. This proccess is invertible and lossless, so we can convert the serialized string back into the original string when we are ready. To play with this concept for arbitrary alphabets, you can visit ",(0,r.kt)("a",{parentName:"p",href:"https://convert.zamicol.com/"},"Zamicol's Base Converter")," which supports these exact operations and comes with many pre-defined alphabets."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local x = 'Hello, world!'\nlocal alphabet = Squash.string.alphabet(x)\nprint(alphabet)\n--  !,Hdelorw\nlocal y = Squash.string.convert(x, alphabet, Squash.string.utf8)\nprint(y)\n-- \x03>q#\x0e\ufffd\nprint(Squash.string.convert(y, Squash.string.utf8, alphabet))\n-- 'Hello, world!'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local y = Squash.string.convert('great sword', Squash.string.lower .. ' ', Squash.string.utf8)\nprint(y)\n-- \x04\ufffdzvFV\ufffd\nprint(Squash.string.convert(y, Squash.string.utf8, Squash.string.lower .. ' '))\n-- 'great sword'\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local y = Squash.string.convert('lowercase', Squash.string.lower, Squash.string.upper)\nprint(y)\n-- LOWERCASE\nprint(Squash.string.convert(y, Squash.string.upper, Squash.string.lower))\n-- lowercase\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local y = Squash.string.convert('123', Squash.string.decimal, Squash.string.binary)\nprint(y)\n-- 1111011\nprint(Squash.string.convert(y, Squash.string.binary, Squash.string.octal))\n-- 173\nprint(Squash.string.convert(y, Squash.string.binary, Squash.string.decimal))\n-- 123\nprint(Squash.string.convert(y, Squash.string.binary, Squash.string.duodecimal))\n-- A3\nprint(Squash.string.convert(y, Squash.string.binary, Squash.string.hexadecimal))\n-- 7B\nprint(Squash.string.convert(y, Squash.string.binary, Squash.string.utf8))\n-- {\n")),(0,r.kt)("h2",{id:"literals"},"Literals"),(0,r.kt)("p",null,"Literals are individual values that can be enumerated and distinguished using just ",(0,r.kt)("inlineCode",{parentName:"p"},"u1"),"s. This is useful for encoding enums of names, orientations, and other unique identifiers with minimal data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local literal = Squash.literal("a", 2, "c", true, "e")\n\nlocal cursor = Squash.cursor()\nliteral.ser(cursor, "c")\nSquash.print(cursor)\n-- Pos: 1 / 8\n-- Buf: { 2 0 0 0 0 0 0 0 }\n--          ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(literal.des(cursor))\n-- "c"\n')),(0,r.kt)("h2",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"Arrays are a classic table type ",(0,r.kt)("inlineCode",{parentName:"p"},"{T}"),". Like strings, which are also arrays (of bytes), after serializing every element in sequence we append a VLQ representing the count. An array can store an array or any other table type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local arr = Squash.array\nlocal float = Squash.number(4)\nlocal myarr = arr(float)\n\nlocal cursor = Squash.cursor()\nmyarr.ser(cursor, {1, 2, 3, 4, 5.5, 6.6, -7.7, -8.9, 10.01})\nSquash.print(cursor)\n-- Pos: 37 / 40\n-- Buf: { 0 0 128 63 0 0 0 64 0 0 64 64 0 0 128 64 0 0 176 64 51 51 211 64 102 102 246 192 102 102 14 193 246 40 32 65 137 0 0 0 }\n--                                                                                                                         ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(myarr.des(cursor))\n-- 1 2 3 4 5.5 6.599999904632568 -7.699999809265137 -8.899999618530273 10.01000022888184\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local arr = Squash.array\nlocal float = Squash.number(4)\nlocal myarr = arr(float, 8)\n\nlocal cursor = Squash.cursor()\nmyarr.ser(cursor, {1, 2, 3, 4, 5.5, 6.6, -7.7, -8.9, 10.01})\nSquash.print(cursor)\n-- Pos: 32 / 40\n-- Buf: { 0 0 128 63 0 0 0 64 0 0 64 64 0 0 128 64 0 0 176 64 51 51 211 64 102 102 246 192 102 102 14 193 0 0 0 0 0 0 0 0 }\n--                                                                                                        ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(myarr.des(cursor))\n-- 1 2 3 4 5.5 6.599999904632568 -7.699999809265137 -8.899999618530273\n")),(0,r.kt)("h2",{id:"maps"},"Maps"),(0,r.kt)("p",null,"Maps are a classic table type ",(0,r.kt)("inlineCode",{parentName:"p"},"{ [T]: U }")," that map T's to U's. A map can store a map or any other table type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local u = Squash.uint\nlocal vec3 = Squash.Vector3\nlocal vec2 = Squash.Vector2\nlocal mymap = Squash.map(vec2(u(2)), vec3(u(3)))\n\nlocal cursor = Squash.cursor()\nmymap.ser(cursor, {\n    [Vector2.new(1, 2)] = Vector3.new(1, 2, 3),\n    [Vector2.new(4, 29)] = Vector3.new(4, 29, 33),\n    [Vector2.new(72, 483)] = Vector3.new(72, 483, 555),\n})\nSquash.print(cursor)\n-- Pos: 40 / 40\n-- Buf: { 43 2 0 227 1 0 72 0 0 227 1 72 0 33 0 0 29 0 0 4 0 0 29 0 4 0 3 0 0 2 0 0 1 0 0 2 0 1 0 131   }\n--                                                                                                    ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(mymap.des(cursor))\n-- {\n--    [Vector2(24346692898)] = 72, 483, 555,\n--    [Vector2(243466928B0)] = 4, 29, 33,\n--    [Vector2(243466928C8)] = 1, 2, 3\n-- }\n")),(0,r.kt)("h2",{id:"t"},"T"),(0,r.kt)("p",null,"If using the TypeScript port of Squash this is irrelevant, but for Luau users, the type system is not powerful enough to take a table of serializers and infer the correct type. To get around this, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Squash.T")," function maps ",(0,r.kt)("inlineCode",{parentName:"p"},"SerDes<T> -> T")," and returns what you give it. It's an identity function that ",(0,r.kt)("em",{parentName:"p"},"lies")," about its type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local T = Squash.T\n\ntypeof(Squash.number(4))\n-- SerDes<number>\ntypeof(T(Squash.number(4)))\n-- number\nprint(Squash.number(4) == T(Squash.number(4)))\n-- true\n")),(0,r.kt)("h2",{id:"records"},"Records"),(0,r.kt)("p",null,"Records (Structs) ",(0,r.kt)("inlineCode",{parentName:"p"},"{ prop1: any, prop2: any, ... }")," map enumerated string identifiers to different values, like a named tuple. Because all keys are string literals known ahead of time, none of them have to be serialized! A record can store a record or any other table type."),(0,r.kt)("p",null,"When defining compound types the code can become verbose and difficult to read. If this is an issue, it is encouraged to store each SerDes in a variable with a shorter name."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local T = Squash.T\nlocal u = Squash.uint\nlocal vlq = Squash.vlq()\nlocal bool = Squash.boolean()\nlocal str = Squash.string()\nlocal float = Squash.number(4)\nlocal vec2 = Squash.Vector2\nlocal arr = Squash.array\nlocal map = Squash.map\nlocal opt = Squash.opt\nlocal record = Squash.record\n\nlocal playerserdes = record {\n    position = T(vec2(float)),\n    health = T(u(1)),\n    name = T(str),\n    poisoned = T(bool),\n    items = T(arr(record {\n        count = T(vlq),\n        name = T(str),\n    })),\n    inns = T(map(str, bool)),\n    equipped = T(opt(str)),\n}\n\nlocal cursor = Squash.cursor()\nplayerserdes.ser(cursor, {\n    position = Vector2.new(287.3855, -13486.3),\n    health = 9,\n    name = "Cedrick",\n    poisoned = true,\n    items = {\n        { name = \'Lantern\', count = 2 },\n        { name = \'Waterskin\', count = 1 },\n        { name = \'Map\', count = 4 },\n    },\n    inns = {\n        [\'The Copper Cauldron\'] = true,\n        Infirmary = true,\n        [\'His Recess\'] = true,\n    },\n    equipped = nil,\n})\nSquash.print(cursor)\n-- Pos: 90 / 90\n-- Buf: { 0 9 1 72 105 115 32 82 101 99 101 115 115 138 1 84 104 101 32 67 111 112 112 101 114 32 67 97 117 108 100 114 111 110 147 1 73 110 102 105 114 109 97 114 121 137 131 130 76 97 110 116 101 114 110 135 129 87 97 116 101 114 115 107 105 110 137 132 77 97 112 131 131 67 101 100 114 105 99 107 135 1 51 185 82 198 88 177 143 67   }\n--                                                                                                                                                                                                                                                                                                                                            ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(playerserdes.des(cursor))\n-- {\n--     ["health"] = 9,\n--     ["inns"] =  \u25bc  {\n--        ["His Recess"] = true,\n--        ["Infirmary"] = true,\n--        ["The Copper Cauldron"] = true\n--     },\n--     ["items"] =  \u25bc  {\n--        [1] =  \u25bc  {\n--           ["count"] = 2,\n--           ["name"] = "Lantern"\n--        },\n--        [2] =  \u25bc  {\n--           ["count"] = 1,\n--           ["name"] = "Waterskin"\n--        },\n--        [3] =  \u25bc  {\n--           ["count"] = 4,\n--           ["name"] = "Map"\n--        }\n--     },\n--     ["name"] = "Cedrick",\n--     ["poisoned"] = true,\n--     ["position"] = 287.385498, -13486.2998\n--  }\n')),(0,r.kt)("h2",{id:"tuples"},"Tuples"),(0,r.kt)("p",null,"Tuple types ",(0,r.kt)("inlineCode",{parentName:"p"},"(T...)")," are like arrays but not wrapped in a table, and each element can be a different type. Tuples cannot be used in table types, and cannot be nested in other tuples."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local S = Squash\nlocal T = S.T\n\nlocal mytuple = S.tuple(\n    T(S.Vector3(S.number(8))),\n    T(S.CFrame(S.int(1))),\n    T(S.BrickColor()),\n    T(S.EnumItem(Enum.HumanoidStateType))\n)\n\nlocal cursor = S.cursor()\nmytuple.ser(cursor, Vector3.new(123456789, 1, 0), CFrame.new(1, 2, 3), BrickColor.new(93), Enum.HumanoidStateType.Freefall)\nS.print(cursor)\n-- Pos: 40 / 40\n-- Buf: { 0 0 0 0 0 0 0 0 0 0 0 0 0 0 240 63 0 0 0 96 52 111 157 65 1 0 0 64 64 0 0 0 64 0 0 128 63 194 0 134   }\n--                                                                                                            ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(mytuple.des(cursor))\n-- 123456792, 1, 0 1, 2, 3, 1, 0, 0, 0, 1, 0, 0, 0, 1 Medium stone grey Enum.HumanoidStateType.Freefall\n")),(0,r.kt)("h2",{id:"tables"},"Tables"),(0,r.kt)("p",null,"Luau tables are extremely versatile data structures that can and do implement every other kind of data structure one can think of. They are ",(0,r.kt)("em",{parentName:"p"},"too")," versatile to optimally serialize in the general case, which is why Squash has the previously listed Array, Map, and Record serializers."),(0,r.kt)("p",null,"Only use this serializer if you cannot guarantee the shape of your table beforehand, as it offers less control and worse size reduction. This is the algorithm that Roblox uses when serializing tables because they can't guarantee the shape of the tables users pass. If you do not know the type of your table but you still need to serialize it, then the ",(0,r.kt)("inlineCode",{parentName:"p"},"Squash.table")," serializer is a last resort."),(0,r.kt)("p",null,"It has to store data for every value, the type of every value, every key, and the type of every key, which makes it significantly larger than the specialized functions. It also does not offer property-specific granularity, instead only letting you map types to serializers for both keys and values alike."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local serdes = Squash.table {\n    number = Squash.number(8),\n    string = Squash.string(),\n    boolean = Squash.boolean(),\n    table = Squash.table {\n        CFrame = Squash.CFrame(Squash.number(4)),\n        Vector3 = Squash.Vector3(Squash.int(2)),\n        number = Squash.vlq(),\n    },\n}\n\nlocal cursor = Squash.cursor()\nserdes.ser(cursor, {\n    wow = -5.352345,\n    [23846.4522] = true,\n    [false] = \'Gaming!\',\n    ThisWontSerialize = DateTime.now(),\n    [{\n        CFrame.new(-24.2435, 2, 3), CFrame.new(), Vector3.new(354, -245, -23),\n        [100] = Vector3.zAxis,\n        [Vector3.zero] = 255,\n    }] = {\n        [1] = CFrame.identity,\n        [2] = Vector3.zero,\n        [3] = 256,\n    },\n})\nSquash.print(cursor)\n-- Pos: 131 / 135\n-- Buf: { 71 97 109 105 110 103 33 135 1 0 2 240 162 175 32 205 104 21 192 0 119 111 119 131 1 1 2 208 68 216 240 156 73 215 64 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 129 0 0 0 0 0 0 0 2 130 0 130 0 0 131 0 131 3 1 0 0 64 64 0 0 0 64 176 242 193 193 1 129 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 130 0 233 255 11 255 98 1 2 131 0 129 127 0 0 0 0 0 0 0 2 1 0 0 0 0 0 2 228 0 133 3 132 0 0 0 0 }\n--                                                                                                                                                                                                                                                                                                                                                                           ^\nlocal buf = Squash.tobuffer(cursor)\n\nlocal cursor = Squash.frombuffer(buf)\nprint(serdes.des(cursor))\n-- {\n--     ["wow"] = -5.352345,\n--     [23846.4522] = true,\n--     [Table(24BE4A11A98)] =  \u25bc  {\n--         [1] = 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,\n--         [2] = 0, 0, 0,\n--         [3] = 256\n--     },\n--     [false] = "Gaming!"\n-- }\n')))}h.isMDXComponent=!0},26863:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/floatingpoint-511015af5d8758076aca99bdfbae89cb.png"},65044:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/floatingpointdouble-6bb419d0e13b26edd712bd7c78838243.png"}}]);